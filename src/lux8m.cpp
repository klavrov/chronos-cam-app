/****************************************************************************
 *  Copyright (C) 2013-2017 Kron Technologies Inc <http://www.krontech.ca>. *
 *                                                                          *
 *  This program is free software: you can redistribute it and/or modify    *
 *  it under the terms of the GNU General Public License as published by    *
 *  the Free Software Foundation, either version 3 of the License, or       *
 *  (at your option) any later version.                                     *
 *                                                                          *
 *  This program is distributed in the hope that it will be useful,         *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
 *  GNU General Public License for more details.                            *
 *                                                                          *
 *  You should have received a copy of the GNU General Public License       *
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.   *
 ****************************************************************************/
#include "math.h"
#include <QDebug>
#include <fcntl.h>
#include <unistd.h>
#include <QResource>
#include <QDir>
#include <QIODevice>

#include "spi.h"
#include "util.h"

#include "defines.h"
#include "cameraRegisters.h"



#include "types.h"
#include "lux2100.h"
#include "lux8m.h"

#include <QSettings>

/* Select binning or windowed mode. */
#define LUX8M_BINNING_MODE	0

/* 4k non-binned full length. */
const UInt8 sram126clk_full4k[] = {
	0x80, 0x00, 0x00, 0x20, 0x08, 0xD0, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20,
	0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08,
	0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3,
	0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20,
	0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08,
	0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3,
	0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20,
	0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08,
	0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3,
	0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20,
	0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08,
	0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3,
	0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20,
	0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08,
	0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53,
	0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20,
	0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08,
	0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53,
	0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20,
	0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08,
	0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53,
	0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20,
	0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08,
	0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x00, 0x09, 0x53, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x53,
	0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80,
	0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C,
	0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43,
	0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80,
	0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C,
	0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43,
	0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80,
	0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C,
	0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43,
	0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80,
	0x01, 0x43, 0x80, 0x1C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x1C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x1C,
	0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43,
	0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80,
	0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C,
	0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43,
	0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80,
	0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C,
	0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43,
	0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80,
	0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C,
	0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43,
	0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80,
	0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x98, 0x00, 0x80, 0x01, 0x43, 0x80, 0x98,
	0x00, 0x00, 0x01, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const lux2100wavetab_t wavetab126clk_full4k = {
	.clocks = 126,
	.length = sizeof(sram126clk_full4k),
	.abnDelay = 25,
	.binning = 0,
	.wavetab = sram126clk_full4k,
};

//1080p windowed from 4k
//Non-binned half length
const UInt8 sram66clk_window1080p[] = {
	0x80, 0x00, 0x00, 0x20, 0x08, 0xD0, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20,
	0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08,
	0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3,
	0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20,
	0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08,
	0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3,
	0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20, 0x09, 0xD3, 0x80, 0x08, 0x00, 0x20,
	0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08,
	0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53,
	0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20,
	0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08,
	0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x20, 0x09, 0x53,
	0x80, 0x08, 0x00, 0x20, 0x09, 0x53, 0x80, 0x08, 0x00, 0x00, 0x09, 0x53, 0x80, 0x3C, 0x00, 0x80,
	0x01, 0x53, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C,
	0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43,
	0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80,
	0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C,
	0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43,
	0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x3C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x1C, 0x00, 0x80,
	0x01, 0x43, 0x80, 0x1C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C,
	0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43,
	0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80,
	0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C,
	0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43, 0x80, 0x9C, 0x00, 0x80, 0x01, 0x43,
	0x80, 0x98, 0x00, 0x80, 0x01, 0x43, 0x80, 0x98, 0x00, 0x00, 0x01, 0x43, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
static const lux2100wavetab_t wavetab66clk_window1080p = {
	.clocks = 66,
	.length = sizeof(sram66clk_window1080p),
	.abnDelay = 25,
	.binning = 0,
	.wavetab = sram66clk_window1080p,
};

const lux2100wavetab_t *lux8mwt[] {
	&wavetab126clk_full4k,
	&wavetab66clk_window1080p,
	NULL
};

#define round(x) (floor(x + 0.5))
//#define SCI_DEBUG_PRINTS

#define LUX2100_MIN_HBLANK 2
#define LUX2100_SOF_DELAY  10
#define LUX2100_LV_DELAY   8

CameraErrortype LUX8M::init(GPMC * gpmc_inst)
{
	CameraErrortype retVal;
	retVal = spi->Init(IMAGE_SENSOR_SPI, 16, 1000000, false, true);	//Invert clock phase
	if(SUCCESS != retVal)
		return retVal;

	dacCSFD = open("/sys/class/gpio/gpio33/value", O_WRONLY);
	if (-1 == dacCSFD)
		return LUX1310_FILE_ERROR;

	gpmc = gpmc_inst;
	wtlist = lux8mwt;

	retVal = initSensor();
	//mem problem before this
	if(SUCCESS != retVal)
		return retVal;

	return SUCCESS;
}

CameraErrortype LUX8M::initSensor()
{
	wavetableSize = 126;
	gain = 1;

	gpmc->write32(IMAGER_FRAME_PERIOD_ADDR, 100*4000);	//Disable integration
	gpmc->write32(IMAGER_INT_TIME_ADDR, 100*4100);

	initDAC();

	initLUX8M();

	delayms(10);

    gpmc->write32(IMAGER_FRAME_PERIOD_ADDR, 100000000/100);	//Enable integration
    gpmc->write32(IMAGER_INT_TIME_ADDR, 100000000/200);

	delayms(50);


	currentRes.hRes = LUX8M_MAX_H_RES;
	currentRes.vRes = LUX8M_MAX_V_RES;
	currentRes.hOffset = 0;
	currentRes.vOffset = 0;
	currentRes.vDarkRows = 0;
	currentRes.bitDepth = LUX2100_BITS_PER_PIXEL;
	setFramePeriod(getMinFramePeriod(&currentRes), &currentRes);
	//mem problem before this
	setIntegrationTime(getMaxIntegrationTime(currentPeriod, &currentRes), &currentRes);

	return SUCCESS;
}

FrameGeometry LUX8M::getMaxGeometry(void)
{
	FrameGeometry size = {
		.hRes = LUX8M_MAX_H_RES,
		.vRes = LUX8M_MAX_V_RES,
		.hOffset = 0,
		.vOffset = 0,
		.vDarkRows = LUX8M_MAX_V_DARK,
		.bitDepth = LUX2100_BITS_PER_PIXEL,
	};
	return size;
}

void LUX8M::setResolution(FrameGeometry *size)
{
	UInt32 hStartBlocks = size->hOffset / LUX2100_HRES_INCREMENT;
	UInt32 hEndblocks = hStartBlocks + (size->hRes / LUX2100_HRES_INCREMENT);
	UInt32 vLastRow = LUX8M_MAX_V_RES + LUX8M_LOW_BOUNDARY_ROWS + LUX8M_HIGH_BOUNDARY_ROWS + LUX8M_HIGH_DARK_ROWS;

	/* Windowed operation - add extra offset to put the readout at the centre. */
	SCIWrite(0x06, (LUX8M_LEFT_DARK_COLUMNS + 0x3E0) + hStartBlocks * LUX2100_HRES_INCREMENT);
	SCIWrite(0x07, (LUX8M_LEFT_DARK_COLUMNS + 0x3E0) + hEndblocks * LUX2100_HRES_INCREMENT - 1);
	//SCIWrite(0x08, (LUX2100_LOW_BOUNDARY_ROWS * 2 + 0x22C) + size->vOffset);
	//SCIWrite(0x09, (LUX2100_LOW_BOUNDARY_ROWS * 2 + 0x22C) + size->vOffset + size->vRes - 1);
	SCIWrite(0x08, 0x0000);
	SCIWrite(0x09, 0x088F);
	if (size->vDarkRows) {
		SCIWrite(0x2A, (vLastRow * 2) - size->vDarkRows * 2);
	}
	SCIWrite(0x2B, size->vDarkRows);

	memcpy(&currentRes, size, sizeof(currentRes));
}

unsigned int LUX8M::enableAnalogTestMode(void)
{
	seqOnOff(false);
	delayms(10);

	/* Switch to analog test mode. */
	SCIWrite(0x04, 0x0000);
	SCIWrite(0x56, 0xB001);

	/* Configure the desired test voltage. */
	SCIWrite(0x67, 0x6D11);

	seqOnOff(true);
	return 31;
}

void LUX8M::disableAnalogTestMode(void)
{
	seqOnOff(false);
	delayms(10);

	/* Disable the test voltage. */
	SCIWrite(0x04, 0x0000);
	SCIWrite(0x67, 0x1E11);
	SCIWrite(0x56, 0x9001);
	seqOnOff(true);
}

Int32 LUX8M::initLUX8M()
{
	writeDACVoltage(LUX2100_VRSTH_VOLTAGE, 3.3);
	writeDACVoltage(LUX2100_VTX2L_VOLTAGE, 0.0);
	writeDACVoltage(LUX2100_VRSTPIX_VOLTAGE, 2.0);
	writeDACVoltage(LUX2100_VABL_VOLTAGE, 0.3);
	writeDACVoltage(LUX2100_VTXH_VOLTAGE, 3.3);
	writeDACVoltage(LUX2100_VTX2H_VOLTAGE, 3.3);
	writeDACVoltage(LUX2100_VTXL_VOLTAGE, 0.0);

	writeDACVoltage(LUX2100_VDR1_VOLTAGE, 2.5);
	writeDACVoltage(LUX2100_VDR2_VOLTAGE, 2.0);
	writeDACVoltage(LUX2100_VDR3_VOLTAGE, 1.5);
	writeDACVoltage(LUX2100_VRDH_VOLTAGE, 0.0);  //Datasheet says this should be grounded
	writeDACVoltage(LUX2100_VPIX_LDO_VOLTAGE, 3.3);
	writeDACVoltage(LUX2100_VPIX_OP_VOLTAGE, 0.0);
	delayms(10);		//Settling time

	setReset(true);
	setReset(false);
	delayms(1);		//Seems to be required for SCI clock to get running

	SCIWrite(0x7E, 0);	//reset all registers
	//delayms(1);

	//Set gain to 2.6
	SCIWrite(0x57, 0x01FF); //gain_sel_samp
	SCIWrite(0x58, 0x030F); //gain_serial, gain_sel_fb
	SCIWrite(0x76, 0x0079); //col_cap_en

	//Set up for 66Tclk wavetable
	SCIWrite(0x34, 0x0042); //Readout delay
	SCIWrite(0x56, 0x9001); //Set up windowed mode
	SCIWrite(0x06, 0x0040+0x3E0); //Start of standard window (x direction)
	SCIWrite(0x07, 0x07BF+0x3E0); //End of standard window (x direction)
	SCIWrite(0x08, 0x0010+0x22C); //Start of standard window (Y direction)
	SCIWrite(0x09, 0x0447+0x22C); //End of standard window (Y direction)
	SCIWrite(0x79, 0x0133); //???


	SCIWrite(0x03, LUX2100_MIN_HBLANK);
	SCIWrite(0x30, LUX2100_SOF_DELAY << 8); //Start of frame delay
	SCIWrite(0x5B, LUX2100_LV_DELAY);       // line valid delay to match ADC latency
	SCIWrite(0x5F, 0x0000); // pwr_en_serializer_b (all seralizers enabled)
	SCIWrite(0x78, 0x0D03); // internal clock timing
	SCIWrite(0x62, 0x2603); // ADC clock controls
	SCIWrite(0x60, 0x0300); // disable on chip termination
	SCIWrite(0x66, 0x0000); // ???
	SCIWrite(0x2D, 0x0084); // state for idle controls
	SCIWrite(0x2E, 0x0000); // state for idle controls
	SCIWrite(0x2F, 0x0040); // state for idle controls
	SCIWrite(0x7D, 0x0001); // internal control register
	SCIWrite(0x6A, 0xAA8A); // internal control register
	SCIWrite(0x6B, 0xA88A); // internal control register
	SCIWrite(0x6C, 0x89AA); // internal control register

	//Training sequence
	SCIWrite(0x53, 0x0FC0); // pclk channel output during vertical blanking
	SCIWrite(0x04, 0x0001); // switch to datapath register space
	SCIWrite(0x03, 0x1FC0); // always output custom digital pattern
	SCIWrite(0x04, 0x0000); // switch back to sensor register space

	//Sensor is now outputting 0xFC0 on all ports. Receiver will automatically sync when the clock phase is right
	autoPhaseCal();

	//Return to data valid mode
	SCIWrite(0x53, 0x0F00); // pclk channel output during vertical blanking
	SCIWrite(0x55, 0x0FC0); // pclk channel output during optical black
	SCIWrite(0x04, 0x0001); // switch to datapath register space
	SCIWrite(0x03, 0x0AB8); // custom digital pattern for blanking output
	SCIWrite(0x05, 0x0007); // delay to match adc latency
	SCIWrite(0x0E, 0x0001); // enable applying adc offset registers during vertical blanking
	SCIWrite(0x04, 0x0000); // switch to sensor register space

	//Load the wavetable
	SCIWriteBuf(0x7F, wavetab126clk_full4k.wavetab, wavetab126clk_full4k.length);
	qDebug() << "loaded wt 126\n";
	//Enable timing engine
	SCIWrite(0x01, 0x0011); // enable the internal timing engine
	return SUCCESS;
}
